import sys
import datetime
import xml.etree.ElementTree as ET
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QPushButton, QFileDialog, QLabel, QTextEdit, QDateEdit, \
    QHBoxLayout
from PyQt5.QtCore import QDate


class LogAnalyzer(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setWindowTitle('Log Analyzer')

        layout = QVBoxLayout()

        # Log File Upload
        self.upload_btn = QPushButton('Upload Log File', self)
        self.upload_btn.clicked.connect(self.upload_log_file)
        layout.addWidget(self.upload_btn)

        self.log_file_label = QLabel('No file uploaded', self)
        layout.addWidget(self.log_file_label)

        # Date Range
        date_layout = QHBoxLayout()

        self.start_date_edit = QDateEdit(calendarPopup=True)
        self.start_date_edit.setDate(QDate.currentDate().addDays(-1))
        date_layout.addWidget(QLabel('Start Date:', self))
        date_layout.addWidget(self.start_date_edit)

        self.end_date_edit = QDateEdit(calendarPopup=True)
        self.end_date_edit.setDate(QDate.currentDate())
        date_layout.addWidget(QLabel('End Date:', self))
        date_layout.addWidget(self.end_date_edit)

        layout.addLayout(date_layout)

        # Error Check
        self.error_check_btn = QPushButton('Check for Errors', self)
        self.error_check_btn.clicked.connect(self.check_for_errors)
        layout.addWidget(self.error_check_btn)

        self.result_text = QTextEdit(self)
        layout.addWidget(self.result_text)

        self.setLayout(layout)

    def upload_log_file(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getOpenFileName(self, "Open Log File", "", "Log Files (*.log);;All Files (*)",
                                                   options=options)
        if file_path:
            self.log_file_path = file_path
            self.log_file_label.setText(f'File: {file_path}')

    def check_for_errors(self):
        if not hasattr(self, 'log_file_path'):
            self.result_text.setText('Please upload a log file first.')
            return

        start_date = self.start_date_edit.date().toPyDate()
        end_date = self.end_date_edit.date().toPyDate()

        filtered_lines = self.filter_logs_by_date(start_date, end_date)

        filtered_log_file_path = 'filtered_log.log'
        with open(filtered_log_file_path, 'w') as file:
            file.writelines(filtered_lines)

        # Check for specific errors
        errors = self.find_errors(filtered_lines)

        self.result_text.setText(f'Filtered logs saved to {filtered_log_file_path}\n\nErrors:\n{errors}')

    def filter_logs_by_date(self, start_date, end_date):
        filtered_lines = []
        include_line = False
        with open(self.log_file_path, 'r') as file:
            for line in file:
                if 'Date:' in line:
                    log_date_str = line.split()[1]
                    log_date = datetime.datetime.strptime(log_date_str, '%m/%d/%Y').date()
                    include_line = start_date <= log_date <= end_date

                if include_line:
                    filtered_lines.append(line)
        return filtered_lines

    def find_errors(self, lines):
        error_lines = []
        current_message = []
        inside_rstream = False
        current_date = None

        for line in lines:
            if 'Date:' in line:
                current_date = line.strip()
            elif '<RStream>' in line:
                inside_rstream = True
                current_message = [line]
            elif '</RStream>' in line:
                inside_rstream = False
                current_message.append(line)
                error_message = self.check_message_for_error(current_message, current_date)
                if error_message:
                    error_lines.append(error_message)
                current_message = []
            elif inside_rstream:
                current_message.append(line)
        return '\n'.join(error_lines)

    def check_message_for_error(self, message_lines, date):
        message = ''.join(message_lines)
        try:
            root = ET.fromstring(message)
            text_response = root.find('.//TextResponse')
            if text_response is not None and "There still are requests to be forwarded. All \"Store And Forward\" requests should be forwarded before closing a batch." in text_response.text:
                return f"{date}\nError: There still are requests to be forwarded. All 'Store And Forward' requests should be forwarded before closing a batch."
        except ET.ParseError:
            pass
        return None

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = LogAnalyzer()
    ex.show()
    sys.exit(app.exec_())
